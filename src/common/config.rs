// use std::collections::HashMap;

// use crate::common::constants::Env;
// use crate::addresses::ethereum::*;


// pub const POOLS:  Vec<HashMap<String, Pool>> = Env::new().[
//     ("ethereum", POOLS_ETH),
// ];
// pub const RPC_ENDPOINTS: HashMap<&str, &str> = [
//     ("ethereum", env.ethereum_http_rpc_url),
// ];

// pub const TOKENS: HashMap<String, HashMap<String, Vec<TokenValue>>> = [
//     ("ethereum", TOKENS_ETH),
// ];




















// import os
// from dotenv import load_dotenv

// from addresses import (
//     ETHEREUM_TOKENS,
//     POLYGON_TOKENS,
//     ARBITRUM_TOKENS,

//     ETHEREUM_POOLS,
//     POLYGON_POOLS,
//     ARBITRUM_POOLS,

//     ETHEREUM_SIMULATION_HANDLERS,
//     ETHEREUM_EXECUTION_HANDLERS,
// )

// load_dotenv(override=True)

// RPC_ENDPOINTS = {
//     'ethereum': os.getenv('ETHEREUM_HTTP_RPC_URL'),
//     'polygon': os.getenv('POLYGON_HTTP_RPC_URL'),
//     'arbitrum': os.getenv('ARBITRUM_HTTP_RPC_URL'),
// }

// WS_ENDPOINTS = {
//     'ethereum': os.getenv('ETHEREUM_WS_RPC_URL'),
//     'polygon': os.getenv('POLYGON_WS_RPC_URL'),
//     'arbitrum': os.getenv('ARBITRUM_WS_RPC_URL'),
// }

// TOKENS = {
//     'ethereum': ETHEREUM_TOKENS,
//     'polygon': POLYGON_TOKENS,
//     'arbitrum': ARBITRUM_TOKENS,
// }

// POOLS = ETHEREUM_POOLS + POLYGON_POOLS + ARBITRUM_POOLS

// SIMULATION_HANDLERS = {
//     'ethereum': ETHEREUM_SIMULATION_HANDLERS,
// }

// EXECUTION_HANDLERS = {
//     'ethereum': ETHEREUM_EXECUTION_HANDLERS,
// }
